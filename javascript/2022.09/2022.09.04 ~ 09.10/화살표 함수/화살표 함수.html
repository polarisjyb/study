<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>

  /*
  화살표 함수는 function 키워드 대신 화살표( => ) 를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있다.
  화살표 함수는 표현만 간략한 것이 아니라 내부 동작도 기존의 함수보다 간략하다.
  특히 화살표 함수는 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다.
  */


  //  화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다.
  const multiplay = (x, y) => x * y;

  multiplay(3, 4);  // 12


  /* 매개변수 선언 */

  // 매개변수가 여러 개인 경우 소괄호 () 안에 매개변수를 선언한다.
  const arrow1 = (x, y) => {};

  // 매개변수가 한 개인 경우 소괄호 () 를 생략할 수 있다.
  const arrow2 = x => {};

  // 매개변수가 없는 경우 소괄호 () 를 생략할 수 없다.
  const arrow3 = () => {};


  /*
    함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {}를 생략할 수있다. 이때 함수 몸체 내부의 문이
    값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환한다.
  */

  // const power = x => x ** 2;

  const power = function (x) {
    return x ** 2;
    
  }

  console.log(power(2)); // 4

  // 위 표현문은 다음과 동일하다.
  // const power = x => { return x ** 2 };


  /*
    함수 몸체를 감싸는 중괄호 {} 를 생략한 경우 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생한다.
    표현식이 아닌 문은 반환할 수 없기 때문이다.
  */

  // const arrow4 = () => const x = 1; //SyntaxError

  // 위표현은 다음과 같이 해석된다.
  // const arrow4 = () => { return const x = 1; };

  // 따라서 함수 몸체가 하나의 문으로 구성된다 해도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호를 생략할 수 없다.
  const arrow4 = () => { const x = 1; };


  /*
    객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호 ()로 감싸 주어야 한다.
  */

  const create = (id, content) => ( {id, content} );
  create(1, 'd'); // {id: 1, content: 'd'}

  // 위 표현은 다음과 동일하다.
  // const create = (id, content) => { return {id, content} };


  /*
    함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {} 를 생략할 수 없다.
    이 때 반환값이 있다면 명시적으로 반환해야 한다.
  */

  const sum = (a, b) => {
    const result = a+b;
    return result;
  }

  sum(2, 3);  // 5

  // const sum = function(a, b) {
  //   const result = a+b;
  //   return result;
  // }


  /*
    화살표 함수도 일급 객체이므로  map(), filter(), reduce() 같은 고차 함수에 인수로 전달할 수 있다.
    이 경우 일반적인 함수 표현식보다 표현이 간결하고 가독성이 좋다.
  */

  // ES5
  [1, 2, 3].map(function (n) {
    return n* 2;
  }); // [2, 4, 6]

  // ES6
  [1, 2, 3].map(n => n * 2);  // [2, 4, 6]

  /* 이처럼 화살표 함수는 콜백 함수로서 정의할 때 유용하다. 화살표 함수는 표현만 간략한 것만이 아니다.
  화살표 함수는 일반 함수의 기능을 간략화했으며 this도 편리하게 설계되었다. */
  


  </script>
</body>
</html>
