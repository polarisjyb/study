/*
  본 예제는 리팩토링 작업에서 흔히 마주치게 되는 패턴이다. 코드는 다소 긴 편이지만, 객체 두개로 이루어진 것을 확인할 수 있다. 아래의 객체리터럴 needObject는 특정 기능을 하기 위해 함수의 매개변수 용도로 사용되어야 하는 '조건'이다. 조건이라, 개발자가 마음대로 바꾸어 사용하기 어렵다. 심지어 조건객체에 해당하는 속성 하나하나는 '원하는 데이터타입'이 따로 지정되어 있다.

  핵심은 _PORT라는 객체리터럴이다. 가정한 요구사항은 다음과 같다.

  1. 서버의 포트를 각 용도마다 다르게 지정하여 핸들링
  2. 포트번호가 바뀔 수 있음
  3. 필요한 포트의 갯수가 달라질 수 있음
  4. 조건에 필요한 타입은 배열

  값이 여러개가 있을 수 있다는 점과, 문자열 편집이 필요한 점을 고려해 객체를 별도로 구성하여 관리하고, 필요한 경우 기능을 한데 묶어 사용하는 것으로 결정하였는데, 이에 대한 표현'방식'은 다를 수 있으나 '접근'은 중요하다. 개발자로서 '값을 묶는' 관리하는 것에 객체가 편하겠다는 '판단'이 이루어졌다.

  하위 객체에 리터럴이긴 하지만, 일단 필요한 데이터를 정리하였고, 공통되게 사용할 속성과 일련의 기능으로 사용될 메서드를 구축하였다. '객체'이기 때문에 데이터량이 얼마든, 모듈화 시킬 수도 있을 것이다. 더 나아가 포트번호도 직접 작성하는 것이 아닌 DB에서 연결하여 대입해줄 수 도 있을 것 이다.

  _PORT 객체는 그 자체로 '데이터'+'기능"이 한데 묶여있으므로, 추상화에 익숙한(한가지의 상징으로 이해하려고 하는) 사람에게는 더할나위없이 머리를 맑게 해주는 효과를 기대할 수 있다.

  메서드 자체에도 복잡한 문자열 템플릿('')을 사용하지 않고 + 덧셈 방식으로 추후에 다시 확인하기 좋게 처리하였다.

  이러한 방식을 여러번 해야한다면, 그 다음 단계의 추상화는 바로 '생성자 함수'로, 이어지는 점을 생각하는 것이 코드의 품질을 높이는 훈련 요소이다. 특이한 점은 메서드의 이름이 지나치게 길다. 이것은 의도한 것으로 함수가 호출되는 순간 사람 눈에는 여전히 함수처럼 보이지만, 사실 return에 의해 배열이 형태가 된다. 함수 자체의 직관성은 매우 떨어지지만, 마치 주석처럼 해당 함수가 무엇을 리턴하는지 어떤 용도인지 목적이 무엇인지까지 작성했으므로 '설명'의 역할을 수행한다.
*/

const _PORT = {
  portlist :{
    "5000" : "live server",
    "3001" : "react",
    "3002" : "react-native",
    "3003" : "vue",
    "3005" : "electron",
    "3006" : "Database",
    "8080" : "Localhost",
  },
  localHostString : "http://127.0.0.1/",
  
  localHostURLPortStringReturnArray: function() {
    console.log(this);
    let tempArray = [];
    for (let portNumberString in this.portlist) {
      let makeURL = this.localHostString + ":" + portNumberString;
      tempArray.push(makeURL);
    }
    return tempArray;
  }
}

const needObject = {
  needArray:_PORT.localHostURLPortStringReturnArray(),
  needResponseHeader: 200,
  isOn: true,
};

console.log(needObject);