<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <script>

    /*
      includes 메서드는 배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false를 반환한다.
      첫 번째 인수로 검색할 대상을 지정한다.

      구문 --> arr.includes(valueToFind[, fromIndex])


      문자나 문자열을 비교할 때, includes() 대소문자를 구분한다.
    */

    const arr1 = [1, 2, 3];

    // 배열에 요소 2가 포함되어 있는지 확인한다.
    console.log(arr1.includes(2)); // true

    // 배열에 요소 100이 포함되어 있는지 확인한다.
    console.log(arr1.includes(100)); // false

    /*
      두 번째 인수(fromIndex)로 검색을 시작할 인덱스를 전달할 수 있다. 두 번째 인수(fromIndex)를 생략할 경우 기본값 0이 설정된다.
      배열의 길이보다 같거나 크다면, false를 반환한다.
      만약 두 번째 인수(fromIndex)에 음수를 전달하면 length 프로퍼티 값과 음수 인덱스를 합산하여
      (length + index) 검색 시작 인덱스를 설정한다.
    */

    const arr2 = [1, 2 ,3];

    // 배열에 요소 1이 포함되어 있는지 인덱스 1부터 확인한다.
    console.log(arr2.includes(1, 1)); // false

    // 배열에 요소 3이 포함되어 있는지 인덱스 2(arr2.length - 1) 부터 확인한다.
    console.log(arr2.includes(3, -1)); // true

    // 배열에 요소 2가 포함되어 있는지 인덱스 2(arr2.length -1) 부터 확인한다.
    console.log(arr2.includes(2, -1)); // false


    const arr3 = ['a', 'b', 'c'];

    // 두 번째 인수(fromIndex) 가 arr3.length 과 같으므로, false를 반환한다. 
    console.log(arr3.includes('c', 3)); // false

    // 두 번째 인수(fromIndex) 가 arr3.length 과 크므로, false를 반환한다. 
    console.log(arr3.includes('c',100)); // false


    /*
      fromIndex가 음수라면, 이 계산된 인덱스는 첫 번째 인수를 찾기 시작할 배열의 위치로 사용되기 위해 연산된다.
      만약 계산된 인덱스가 -1 * array.length 보다 작거나 같다면, 전체 배열이 검색된다.
    */

    const arr4 = ['a', 'b', 'c'];

    console.log(arr4.includes('a', -100)); // true
    console.log(arr4.includes('b', -100)); // true
    console.log(arr4.includes('c', -100)); // true
    console.log(arr4.includes('b', -2)); // true
    console.log(arr4.includes('a', -3)); // true
    console.log(arr4.includes('c', -1)); // true
    console.log(arr4.includes('c', -4)); // true


    /*
      배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환하는 indexOf 메서드를 사용하여도 배열 내에 특정 요소가
      포함되어 있는지 확인할 수 있다. 하지만 indexOf 메서드를 사용하면 반환값이 -1인지 확인해 보아야 하고
      배열에 NaN이 포함되어 있는지 확인할 수 없다는 문제가 있다.
    */

    [NaN].indexOf(NaN) !== -1; // false
    [NaN].includes(NaN); // true

    [1, 2, NaN].includes(NaN); // true


    /* 마지막 정리 ( 문제 풀이 )*/
    [1, 2, 3].includes(2);     // true
    [1, 2, 3].includes(4);     // false
    [1, 2, 3].includes(3, 3);  // false
    [1, 2, 3].includes(3, -1); // true
    [1, 2, NaN].includes(NaN); // true



  </script>

</body>
</html>